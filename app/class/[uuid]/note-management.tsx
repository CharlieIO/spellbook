/**
* This code was generated by v0 by Vercel.
* @see https://v0.dev/t/XEk7nD8UOZi
* Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
*/
'use client'
import { Button } from "@/components/ui/button"
import { JSX, SVGProps, useState, useEffect } from "react"
import UploadImage from "./UploadImage";
import NoteCard from "./NoteCard";
import { CustomPagination } from "@/components/pagination"; // Import CustomPagination from the correct location
import NoteCardSkeleton from "./NoteCardSkeleton";

interface NoteManagementProps {
  classUuid: string;
}

export function NoteManagement({ classUuid }: NoteManagementProps) {
  const [images, setImages] = useState<{url: string, key: string}[]>([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(0); // State to track total pages
  const [isLoading, setIsLoading] = useState(false);
  const imagesPerPage = 4;

  useEffect(() => {
    setIsLoading(true); // Set loading to true before fetching images
    fetchImages(currentPage, imagesPerPage);
  }, [currentPage]);

  async function fetchImages(page = 1, limit = imagesPerPage) {
    try {
      const response = await fetch(`/api/class/notes?classUuid=${classUuid}&page=${page}&limit=${limit}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      if (!response.ok) {
        throw new Error('Failed to fetch images');
      }
      const data = await response.json();
      const formattedImages = data.images.map((img: {url: string, key: string}) => ({
        url: img.url,
        key: img.key
      }));
      setImages(formattedImages); // Assuming the API returns an object with an 'images' array containing URLs and keys
      setTotalPages(data.totalPages); // Assuming the API returns the total number of pages
    } catch (error) {
      console.error('Error fetching images:', error);
    } finally {
      setIsLoading(false);
    }
  }

  const handleUpload = async (files: FileList | null) => {
    if (files && classUuid) {
      const fileNames = Array.from(files).map(file => file.name);
      try {
        const presignedUrls = await fetchPresignedUrls(fileNames, classUuid);
        await uploadFilesToSignedUrls(files, presignedUrls);
        console.log('All files uploaded successfully');
        fetchImages(currentPage, imagesPerPage); // Refresh images after upload
      } catch (error) {
        console.error('Error during file upload:', error);
      }
    } else {
      console.error('No files to upload or class UUID is missing');
    }
  };

  async function fetchPresignedUrls(fileNames: string[], classUuid: string) {
    const response = await fetch(`/api/class/notes`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        classUuid: classUuid,
        numberOfFiles: fileNames.length
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to fetch presigned URLs');
    }

    const jsonResponse = await response.json();
    if (!jsonResponse || !Array.isArray(jsonResponse)) {
      throw new Error('Invalid response structure');
    }

    const presignedFiles = jsonResponse.map((file: { presignedUrl: any; fileKey: any; }) => ({
      presignedUrl: file.presignedUrl,
      fileKey: file.fileKey
    }));
    return presignedFiles;
  }

  async function uploadFilesToSignedUrls(files: FileList, presignedUrls: { presignedUrl: string; fileKey: string }[]) {
    await Promise.all(presignedUrls.map(async (presignedUrl, index) => {
      const file = files[index];
      const uploadResponse = await fetch(presignedUrl.presignedUrl, {
        method: 'PUT',
        headers: {
          'Content-Type': file.type
        },
        body: file
      });
      if (!uploadResponse.ok) {
        throw new Error(`Failed to upload file: ${file.name}`);
      }

      console.log(`File uploaded successfully: ${presignedUrl.fileKey}`);
    }));
  }

  const handleDelete = async (imageKey: string) => {
    try {
      const response = await fetch(`/api/class/notes`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ imageKey })
      });
      if (!response.ok) {
        throw new Error('Failed to delete image');
      }
      setImages(currentImages => currentImages.filter(image => image.key !== imageKey));
      console.log(`Image deleted successfully: ${imageKey}`);
    } catch (error) {
      console.error('Error deleting image:', error);
    }
  };

  const handlePreviousPage = () => {
    setCurrentPage(currentPage => Math.max(1, currentPage - 1));
  };

  const handleNextPage = () => {
    setCurrentPage(currentPage => currentPage + 1);
  };

  return (
    <main className="flex flex-col items-center justify-center w-full h-full p-4 md:p-6 lg:p-8">
      <div className="max-w-3xl w-full">
        <UploadImage onUpload={handleUpload} />
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {isLoading ? (
            Array.from({ length: imagesPerPage }, (_, index) => (
              <NoteCardSkeleton key={index} index={index} />
            ))
          ) : (
            images.map((image, index) => (
              <NoteCard key={index} imageSrc={image.url} onDelete={() => handleDelete(image.key)} />
            ))
          )}
        </div>
        {totalPages > 1 && (
        <div className="container mt-4 px-4 md:px-6">
          <CustomPagination currentPage={currentPage} totalPages={totalPages} onPageChange={setCurrentPage} />
        </div>
      )}
      </div>
    </main>
  )
}

function TrashIcon(props: JSX.IntrinsicAttributes & SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M3 6h18" />
      <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
      <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
    </svg>
  )
}

